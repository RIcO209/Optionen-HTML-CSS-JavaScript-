const grid = document.getElementById('game-grid');
const scoreDisplay = document.getElementById('score');
const gameOverScreen = document.getElementById('game-over-screen');
const saveScoreForm = document.getElementById('save-score-form');
const playerNameInput = document.getElementById('player-name');

const rows = 20;
const cols = 10;
let score = 0;
let gameInterval;

// Grid erstellen
const cells = [];
for (let r = 0; r < rows; r++) {
  for (let c = 0; c < cols; c++) {
    const cell = document.createElement('div');
    grid.appendChild(cell);
    cells.push(cell);
  }
}

// Tetrimino-Formen
const shapes = [
  [1, cols + 1, cols * 2 + 1, 2], // L-Form
  [0, 1, cols, cols + 1],        // Quadrat
  [1, cols, cols + 1, cols + 2], // T-Form
  [0, 1, cols + 1, cols + 2],    // Z-Form
  [1, cols + 1, cols * 2 + 1, cols * 3 + 1], // I-Form
];

let currentPosition = 4;
let currentShape = shapes[Math.floor(Math.random() * shapes.length)];

// Zeichne Tetrimino
function draw() {
  currentShape.forEach(index => {
    cells[currentPosition + index].classList.add('active');
    cells[currentPosition + index].style.background = '#f39c12';
  });
}

// Entferne Tetrimino
function undraw() {
  currentShape.forEach(index => {
    cells[currentPosition + index].classList.remove('active');
    cells[currentPosition + index].style.background = '#444';
  });
}

// Bewegung nach unten
function moveDown() {
  undraw();
  currentPosition += cols;
  draw();
  freeze();
}

// Fixiere Tetrimino, wenn er den Boden erreicht
function freeze() {
  if (currentShape.some(index => 
    currentPosition + index + cols >= rows * cols || 
    cells[currentPosition + index + cols].classList.contains('taken')
  )) {
    currentShape.forEach(index => cells[currentPosition + index].classList.add('taken'));
    currentShape = shapes[Math.floor(Math.random() * shapes.length)];
    currentPosition = 4;
    draw();
    checkRow();
    if (currentShape.some(index => cells[currentPosition + index].classList.contains('taken'))) {
      gameOver();
    }
  }
}

// Reihen überprüfen und löschen
function checkRow() {
  for (let r = 0; r < rows; r++) {
    const row = Array.from({ length: cols }, (_, i) => r * cols + i);
    if (row.every(index => cells[index].classList.contains('taken'))) {
      row.forEach(index => {
        cells[index].classList.remove('taken', 'active');
        cells[index].style.background = '#444';
      });
      const removed = cells.splice(r * cols, cols);
      grid.prepend(...removed);
      score += 10;
      scoreDisplay.textContent = `Score: ${score}`;
    }
  }
}

// Game Over
function gameOver() {
  clearInterval(gameInterval);
  gameOverScreen.classList.remove('hidden'); // Zeige den Game-Over-Bildschirm
}

// Steuerung
function control(e) {
  if (e.key === 'ArrowLeft') moveLeft();
  if (e.key === 'ArrowRight') moveRight();
  if (e.key === 'ArrowDown') moveDown();
}

function moveLeft() {
  undraw();
  if (!currentShape.some(index => (currentPosition + index) % cols === 0)) {
    currentPosition -= 1;
  }
  if (currentShape.some(index => cells[currentPosition + index]?.classList.contains('taken'))) {
    currentPosition += 1;
  }
  draw();
}

function moveRight() {
  undraw();
  if (!currentShape.some(index => (currentPosition + index) % cols === cols - 1)) {
    currentPosition += 1;
  }
  if (currentShape.some(index => cells[currentPosition + index]?.classList.contains('taken'))) {
    currentPosition -= 1;
  }
  draw();
}

// Punktestand speichern
saveScoreForm.addEventListener('submit', (e) => {
  e.preventDefault();
  const playerName = playerNameInput.value.trim();
  if (playerName) {
    const leaderboard = JSON.parse(localStorage.getItem('leaderboard')) || [];
    leaderboard.push({ name: playerName, score });
    localStorage.setItem('leaderboard', JSON.stringify(leaderboard));
    window.location.href = 'leaderboard.html';
  }
});

document.addEventListener('keydown', control);
draw();
gameInterval = setInterval(moveDown, 1000);
