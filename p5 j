const grid = document.getElementById('game-grid');
const scoreDisplay = document.getElementById('score');
const rankingList = document.getElementById('ranking-list');
const rows = 20;
const cols = 10;
let score = 0;

// Spielfeld erstellen
const cells = [];
for (let r = 0; r < rows; r++) {
  for (let c = 0; c < cols; c++) {
    const cell = document.createElement('div');
    grid.appendChild(cell);
    cells.push(cell);
  }
}

// Formen für Tetriminos
const shapes = [
  [1, cols + 1, cols * 2 + 1, 2], // L-Form
  [0, 1, cols, cols + 1],        // Quadrat
  [1, cols, cols + 1, cols + 2], // T-Form
  [0, 1, cols + 1, cols + 2],    // Z-Form
  [1, cols + 1, cols * 2 + 1, cols * 3 + 1], // I-Form
];

// Aktueller Tetrimino
let currentPosition = 4;
let currentShape = shapes[Math.floor(Math.random() * shapes.length)];
let currentRotation = 0;

// Rangliste laden
let rankings = JSON.parse(localStorage.getItem('rankings')) || [];

// Rangliste aktualisieren
function updateRankings() {
  rankingList.innerHTML = '';
  rankings.forEach(entry => {
    const li = document.createElement('li');
    li.textContent = `${entry.name}: ${entry.score}`;
    rankingList.appendChild(li);
  });
}

// Zeichnen des aktuellen Tetriminos
function draw() {
  currentShape.forEach(index => {
    cells[currentPosition + index].classList.add('active');
    cells[currentPosition + index].style.background = '#f39c12';
  });
}

// Entfernen des aktuellen Tetriminos
function undraw() {
  currentShape.forEach(index => {
    cells[currentPosition + index].classList.remove('active');
    cells[currentPosition + index].style.background = '#444';
  });
}

// Bewegen nach unten
function moveDown() {
  undraw();
  currentPosition += cols;
  draw();
  freeze();
}

// Blöcke fixieren
function freeze() {
  if (currentShape.some(index => 
    currentPosition + index + cols >= rows * cols || 
    cells[currentPosition + index + cols].classList.contains('taken')
  )) {
    currentShape.forEach(index => cells[currentPosition + index].classList.add('taken'));
    currentShape = shapes[Math.floor(Math.random() * shapes.length)];
    currentPosition = 4;
    draw();
    checkRow();
    if (currentShape.some(index => cells[currentPosition + index].classList.contains('taken'))) {
      gameOver();
    }
  }
}

// Reihen prüfen und löschen
function checkRow() {
  for (let r = 0; r < rows; r++) {
    const row = Array.from({ length: cols }, (_, i) => r * cols + i);
    if (row.every(index => cells[index].classList.contains('taken'))) {
      row.forEach(index => {
        cells[index].classList.remove('taken', 'active');
        cells[index].style.background = '#444';
      });
      const removed = cells.splice(r * cols, cols);
      grid.prepend(...removed);
      score += 10;
      scoreDisplay.textContent = `Score: ${score}`;
    }
  }
}

// Steuerung
function control(e) {
  if (e.key === 'ArrowLeft') moveLeft();
  if (e.key === 'ArrowRight') moveRight();
  if (e.key === 'ArrowDown') moveDown();
  if (e.key === 'r' || e.key === 'R') rotate();
}

// Nach links bewegen
function moveLeft() {
  undraw();
  if (!currentShape.some(index => (currentPosition + index) % cols === 0)) {
    currentPosition -= 1;
  }
  if (currentShape.some(index => cells[currentPosition + index].classList.contains('taken'))) {
    currentPosition += 1;
  }
  draw();
}

// Nach rechts bewegen
function moveRight() {
  undraw();
  if (!currentShape.some(index => (currentPosition + index) % cols === cols - 1)) {
    currentPosition += 1;
  }
  if (currentShape.some(index => cells[currentPosition + index].classList.contains('taken'))) {
    currentPosition -= 1;
  }
  draw();
}

// Tetrimino rotieren
function rotate() {
  undraw();
  currentRotation = (currentRotation + 1) % currentShape.length;
  currentShape = shapes[currentRotation];
  draw();
}

// Spiel beenden
function gameOver() {
  clearInterval(gameInterval);
  const name = prompt('Game Over! Gib deinen Namen ein:');
  if (name) {
    rankings.push({ name, score });
    rankings.sort((a, b) => b.score - a.score);
    localStorage.setItem('rankings', JSON.stringify(rankings));
    updateRankings();
  }
  alert('Drücke F5, um neu zu starten.');
}

document.addEventListener('keydown', control);
draw();
const gameInterval = setInterval(moveDown, 1000);
updateRankings();
